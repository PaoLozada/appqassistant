import ExcelJS from "exceljs";
import type { TestPlan } from "./types";
import { Row } from "react-day-picker";

// ðŸŽ¨ Paleta de colores
const COLORS = {
    primary: "667eea",
    accent: "764ba2",
    textLight: "FFFFFF",
    rowAlt: "F9F6FA", // fondo alterno para filas
    border: "E6E6E6",
};

// âœ… Helper para crear un estilo de borde uniforme
const BORDER_STYLE: Partial<ExcelJS.Borders> = {
    top: { style: "thin", color: { argb: COLORS.border } },
    left: { style: "thin", color: { argb: COLORS.border } },
    bottom: { style: "thin", color: { argb: COLORS.border } },
    right: { style: "thin", color: { argb: COLORS.border } },
};

// âœ… Helper para aplicar estilo de encabezado con degradado
function applyHeaderGradient(cell: ExcelJS.Cell) {
    cell.fill = {
        type: "gradient",
        gradient: "angle",
        degree: 0,
        stops: [
            { position: 0, color: { argb: COLORS.primary } },
            { position: 1, color: { argb: "000000" } },
        ],
    };
    cell.font = { color: { argb: COLORS.textLight }, bold: true, size: 13 };
    cell.alignment = { horizontal: "center", vertical: "middle" };
}

// âœ… Helper para aplicar estilo a filas alternas
function applyAlternateRows(sheet: ExcelJS.Worksheet) {
    sheet.eachRow((row, rowNumber) => {
        if (rowNumber > 1 && rowNumber % 2 === 0) {
            row.eachCell((cell) => {
                cell.fill = {
                    type: "pattern",
                    pattern: "solid",
                    fgColor: { argb: COLORS.rowAlt },
                };
            });
        }
    });
}

// âœ… FunciÃ³n principal
export async function generateTestPlanExcel(
    testPlan: TestPlan,
    planName: string
): Promise<Buffer> {
    const wb = new ExcelJS.Workbook();
    wb.creator = "QAssistant";
    wb.created = new Date();

    // ðŸŸ£ HOJA: Resumen
    const resumen = wb.addWorksheet("ðŸ’Ž Resumen", {
        properties: { tabColor: { argb: COLORS.primary } },
    });

    resumen.getColumn(1).width = 25;
    resumen.getColumn(2).width = 70;
    resumen.mergeCells("A2:B2");
    resumen.mergeCells("A3:B3");

    const titleCell = resumen.getCell("A2");
    titleCell.value = `PLAN DE PRUEBAS`;
    titleCell.font = { bold: true, size: 20, color: { argb: COLORS.primary } };

    const subtitleCell = resumen.getCell("A3");
    subtitleCell.value = planName;
    subtitleCell.font = { size: 14, color: { argb: COLORS.accent }, italic: true };

    resumen.addRow([]);
    resumen.addRow(["ðŸ“… Fecha de generaciÃ³n", new Date().toLocaleDateString()]);
    resumen.addRow(["ðŸ§  Generado por", "QAssistant (IA + Expertise QA - ðŸ‘©â€ðŸ’» Paola Lozada)"]);
    resumen.addRow(["ðŸ’¬ DescripciÃ³n", testPlan.description || ""]);
    resumen.addRow(["ðŸŒ Fuente", testPlan.source || "No especificada"]);
    resumen.addRow(["ðŸŽ¯ Objetivos", "âœ” " + testPlan.objectives.join("\nâœ” ")]);
    resumen.addRow(["ðŸ“‹ Ãreas incluidas","ðŸ“Œ " + testPlan.scope.included.join("\nðŸ“Œ ")]);
    resumen.addRow(["ðŸš« Ãreas excluidas", "â¬… " + testPlan.scope.excluded.join("\nâ¬… ")]);
    resumen.addRow([]);

    applyAlternateRows(resumen);




    // ðŸŸ  HOJA: Riesgos
    const risksSheet = wb.addWorksheet("âš ï¸ Riesgos", {
        properties: { tabColor: { argb: COLORS.primary } },
    });
    risksSheet.columns = [
        { header: "#", key: "idx", width: 6 },
        { header: "Riesgo", key: "description", width: 60 },
        { header: "Impacto", key: "impact", width: 14 },
        { header: "Probabilidad", key: "probability", width: 14 },
        { header: "MitigaciÃ³n", key: "mitigation", width: 60 },
    ];
    risksSheet.getRow(1).eachCell((cell) => applyHeaderGradient(cell));
    risksSheet.views = [{ state: "frozen", ySplit: 1 }];

    testPlan.risks.forEach((r, i) => {
        risksSheet.addRow({ idx: i + 1, ...r });
    });
    applyAlternateRows(risksSheet);

    // ðŸ”µ HOJA: Casos de prueba
    const tcSheet = wb.addWorksheet("ðŸ§ª Casos de Prueba", {
        properties: { tabColor: { argb: COLORS.primary } },
    });
    tcSheet.columns = [
        { header: "TC #", key: "tc", width: 8 },
        { header: "TÃ­tulo", key: "title", width: 40 },
        { header: "Prioridad", key: "priority", width: 12 },
        { header: "Tipo", key: "type", width: 18 },
        { header: "Automatizable", key: "automatable", width: 17 },
        { header: "Precondiciones", key: "preconditions", width: 40 },
        { header: "Pasos", key: "steps", width: 80 },
        { header: "Resultado esperado", key: "expected", width: 60 },
    ];
    tcSheet.getRow(1).eachCell((cell) => applyHeaderGradient(cell));
    tcSheet.views = [{ state: "frozen", ySplit: 1 }];

    testPlan.testCases.forEach((tc, i) => {
        tcSheet.addRow({
            tc: `TC-${i + 1}`,
            title: tc.title,
            priority: tc.priority,
            type: tc.type,
            automatable: tc.automatable ? "SÃ­" : "No",
            preconditions: "âœ” " + tc.preconditions.join("\nâœ” "),
            steps: "âœ” " + tc.steps.join("\nâœ” "),
            expected: tc.expectedResult,
        });
    });

    applyAlternateRows(tcSheet);    
    risksSheet.getRow(1).height = 17;

    // ðŸŸ¢ HOJA: EstimaciÃ³n de tiempos
    const timeSheet = wb.addWorksheet("â±ï¸ EstimaciÃ³n", {
        properties: { tabColor: { argb: COLORS.primary } },
    });
    timeSheet.columns = [
        { header: "Fase", key: "name", width: 30 },
        { header: "DuraciÃ³n (dÃ­as)", key: "duration", width: 18 },
        { header: "JustificaciÃ³n", key: "justification", width: 60 },
    ];
    timeSheet.getRow(1).eachCell((cell) => applyHeaderGradient(cell));
    timeSheet.views = [{ state: "frozen", ySplit: 1 }];
    testPlan.timeEstimation.phases.forEach((p) => timeSheet.addRow(p));
    timeSheet.addRow([]);
    const row_total = timeSheet.addRow(["Tiempo total estimado", testPlan.timeEstimation.totalDays]);
    const cell_total = row_total.getCell(1);
    cell_total.font = { bold: true, size: 14, color: { argb: "667eea" } }; 
    const cell_2_total = row_total.getCell(2);
    cell_2_total.font = { bold: true, size: 14, color: { argb: "667eea" } };     

    timeSheet.addRow([]);
    timeSheet.addRow([]);
    const row_fac = timeSheet.addRow(["Factores considerados", "", "âœ” " + testPlan.timeEstimation.factors.join("\nâœ” ")]);
    const cell_fac = row_fac.getCell(1);
    cell_fac.font = { bold: true, size: 14, color: { argb: "667eea" } }; 
    

    applyAlternateRows(timeSheet);
    timeSheet.getRow(1).height = 17;
    

    // ðŸ§  HOJA: Estrategia
    const strat = wb.addWorksheet("âš™ï¸ Estrategia", {
        properties: { tabColor: { argb: COLORS.primary } },
    });
    strat.columns = [
        { header: "SecciÃ³n", key: "section", width: 30 },
        { header: "Detalle", key: "detail", width: 100 },
    ];
    strat.getRow(1).eachCell((cell) => applyHeaderGradient(cell));
    strat.views = [{ state: "frozen", ySplit: 1 }];
    strat.addRow(["Enfoque general", testPlan.strategy.approach]);
    strat.addRow([
        "TÃ©cnicas",
        "ðŸ§© " + testPlan.strategy.techniques.map((t) => `${t.name}: ${t.description}`).join("\nðŸ§© "),
    ]);
    strat.addRow(["Criterios de entrada", "ðŸ”º " + testPlan.strategy.entryCriteria.join("\nðŸ”º ")]);
    strat.addRow(["Criterios de salida", "ðŸ”» " + testPlan.strategy.exitCriteria.join("\nðŸ”» ")]);
    applyAlternateRows(strat);
    strat.getRow(1).height = 17;

    // ðŸ§© HOJA: Entorno & Herramientas
    const env = wb.addWorksheet("ðŸ’» Entorno & Herramientas", {
        properties: { tabColor: { argb: COLORS.primary } },
    });
    env.columns = [
        { header: "Tipo", key: "type", width: 18 },
        { header: "Nombre / Fase", key: "name", width: 30 },
        { header: "PropÃ³sito / Config", key: "purpose", width: 60 },
    ];
    env.getRow(1).eachCell((cell) => applyHeaderGradient(cell));
    env.views = [{ state: "frozen", ySplit: 1 }];
    testPlan.environment.environments.forEach((e) =>
        env.addRow({ type: "Entorno", name: e.name, purpose: `${e.purpose} â€” ${e.configuration}` })
    );
    testPlan.environment.tools.forEach((t) =>
        env.addRow({ type: "Herramienta", name: t.name, purpose: t.purpose })
    );
    env.addRow([]);
    
    const row_env = env.addRow(["Datos de prueba", "", "âœ” " + testPlan.environment.testData.join("\nâœ” ")]);
    const cell_env = row_env.getCell(1);
    cell_env.font = { bold: true, size: 14, color: { argb: "667eea" } }; 
    cell_env.alignment = { horizontal: "center", vertical: "middle" };

    applyAlternateRows(env);
    risksSheet.getRow(1).height = 17;

    // âœ¨ Ajustes finales: bordes, alineaciÃ³n y altura dinÃ¡mica mejorada
    wb.eachSheet((sheet) => {
        sheet.eachRow((row) => {
            if (row.number === 1) return;
            let maxLines = 1;
            row.eachCell((cell) => {
                cell.border = BORDER_STYLE;
                cell.alignment = { wrapText: true, vertical: "top" };

                const value = cell.value ? cell.value.toString() : "";
                const lines = value.split("\n").length;
                const extra = Math.ceil(value.length / 60); // detecta texto largo sin saltos
                const total = Math.max(lines, extra);
                if (total > maxLines) maxLines = total;
            });

            // Altura mÃ¡s cÃ³moda y proporcional
            row.height = Math.min(350, 22 + maxLines * 22);
        });
    });




    const buffer = await wb.xlsx.writeBuffer();
    return Buffer.from(buffer);
}
